<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>nanotune.model.capacitancemodel &mdash; nanotune 0.1.0+410.g0d8a2084 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link href="../../../_static/style.css" rel="stylesheet" type="text/css">

</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html" class="icon icon-home"> nanotune
          </a>
              <div class="version">
                0.1.0+410.g0d8a2084
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../overview/index.html">Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quantum_dots/index.html">Quantum dots</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tuning/index.html">Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../device/index.html">Device abstraction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../drivers/index.html">Instruments &amp; interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../data/index.html">Data</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../fit/index.html">Data fitting</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../classification/index.html">Classification</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../capacitance_model/index.html">Capacitance model</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../configuration/index.html">Configuration</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">nanotune API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">nanotune</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>nanotune.model.capacitancemodel</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for nanotune.model.capacitancemodel</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">Any</span>
<span class="kn">import</span> <span class="nn">numpy.typing</span> <span class="k">as</span> <span class="nn">npt</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy</span> <span class="k">as</span> <span class="nn">sc</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">json</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">copy</span>

<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">inv</span>
<span class="kn">from</span> <span class="nn">numpy.linalg</span> <span class="kn">import</span> <span class="n">multi_dot</span>

<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">gaussian_filter</span>

<span class="kn">from</span> <span class="nn">qcodes</span> <span class="kn">import</span> <span class="n">Instrument</span><span class="p">,</span> <span class="n">ChannelList</span><span class="p">,</span> <span class="n">Parameter</span>
<span class="kn">from</span> <span class="nn">qcodes.dataset.measurements</span> <span class="kn">import</span> <span class="n">Measurement</span>
<span class="kn">from</span> <span class="nn">qcodes.tests.instrument_mocks</span> <span class="kn">import</span> <span class="n">DummyInstrument</span>
<span class="kn">from</span> <span class="nn">qcodes.dataset.experiment_container</span> <span class="kn">import</span> <span class="n">load_by_id</span>

<span class="kn">import</span> <span class="nn">nanotune</span> <span class="k">as</span> <span class="nn">nt</span>
<span class="kn">from</span> <span class="nn">nanotune.model.node</span> <span class="kn">import</span> <span class="n">Node</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>

<span class="n">LABELS</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">nt</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">][</span><span class="s2">&quot;labels&quot;</span><span class="p">])</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
<span class="n">N_2D</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">][</span><span class="s2">&quot;standard_shapes&quot;</span><span class="p">][</span><span class="s2">&quot;2&quot;</span><span class="p">]</span>
<span class="n">N_1D</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">][</span><span class="s2">&quot;standard_shapes&quot;</span><span class="p">][</span><span class="s2">&quot;1&quot;</span><span class="p">]</span>
<span class="c1"># elem_charge = 1.60217662 * 10e-19</span>
<span class="n">elem_charge</span> <span class="o">=</span> <span class="mi">1</span>
<span class="n">N_lmt_type</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span>


<div class="viewcode-block" id="CapacitanceModel"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel">[docs]</a><span class="k">class</span> <span class="nc">CapacitanceModel</span><span class="p">(</span><span class="n">Instrument</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Implementation of a general capacitance model with an arbitrary number</span>
<span class="sd">    of dots and gates. It simulates weakly coupled quantum dots with well</span>
<span class="sd">    localized charges and is a classical description based on two assumptions:</span>
<span class="sd">    (1) Coulomb interactions between electrons on dots and in reservoirs are</span>
<span class="sd">    parametrized by constant capacitances. (2) The single-particle energy-level</span>
<span class="sd">    spectrum is considered independent of electron interactions and the number</span>
<span class="sd">    of electrons, meaning that quantum mechanical energy spacings are not taken</span>
<span class="sd">    into account.</span>
<span class="sd">    The system of electrostatic gates, dots and reservoirs is represented by a</span>
<span class="sd">    system of conductors connected via resistors and capacitors.</span>

<span class="sd">    Being based on</span>
<span class="sd">    https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.75.1,</span>
<span class="sd">    the implementation uses the same terminology including charge and</span>
<span class="sd">    voltage nodes, representing quantum dots and electrostatic gates</span>
<span class="sd">    respectively, and electron and hole triple points.</span>

<span class="sd">    The capacitor connecting node :math:`j` and node :math:`k` has a</span>
<span class="sd">    capacitance :math:`C_{jk}` and stores a charge :math:`q_{jk}`.</span>
<span class="sd">    We distinguish between charge and voltage sub-systems, and thus their</span>
<span class="sd">    respective sub-matrices:</span>

<span class="sd">    .. math::</span>
<span class="sd">        :nowrap:</span>

<span class="sd">        \mathbf{C} := \\begin{pmatrix}</span>
<span class="sd">            \\mathbf{C_{cc}} &amp; \\mathbf{C_{cv}} \\\</span>
<span class="sd">            \\mathbf{C_{vc}} &amp; \\mathbf{C_{vv}}</span>
<span class="sd">        \\end{pmatrix}</span>

<span class="sd">    Diagonal elements of the capacitance matrix, :math:`C_{jj}`, are total</span>
<span class="sd">    capacitances of each node and carry the opposite sign of the matrix&#39;s</span>
<span class="sd">    off-diagonal elements. The off-diagonal elements of</span>
<span class="sd">    :math:`\mathbf{\mathbf{C_{cc}}}` are capacitances between charge nodes,</span>
<span class="sd">    while the off-diagonal elements of :math:`\mathbf{\mathbf{C_{vv}}}` are</span>
<span class="sd">    capacitances between voltage nodes. The elements of</span>
<span class="sd">    :math:`\mathbf{\mathbf{C_{cv}}}` are capacitances between voltage and</span>
<span class="sd">    charge nodes, and allow to calculate so-called virtual gate coefficients -</span>
<span class="sd">    useful knobs in semiconductor qubit experiments.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">charge_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">voltage_nodes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>  <span class="c1"># charge configuration</span>
        <span class="n">V_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">C_cc_off_diags</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">C_cv</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">db_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;capa_model_test.db&quot;</span><span class="p">,</span>
        <span class="n">db_folder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">nt</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;db_folder&quot;</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Init method of CapacitanceModel class.</span>

<span class="sd">        Args:</span>
<span class="sd">            name: name identifier to be passed to qc.Instrument</span>
<span class="sd">            charge_nodes: dictionary with charge nodes of the model,</span>
<span class="sd">                mapping integer node IDs to string labels.</span>
<span class="sd">            voltage_nodes: dictionary with voltage nodes of the model,</span>
<span class="sd">                mapping integer node IDs to string labels.</span>
<span class="sd">            N: initial charge configuration, i.e. number of charges on</span>
<span class="sd">                each dot. Index of entry corresponds to charge node layout ID.</span>
<span class="sd">            V_v: voltages to set on voltage nodes. Index of entry</span>
<span class="sd">                corresponds to charge node layout ID.</span>
<span class="sd">            C_cc_off_diags: capacitances between charge nodes.</span>
<span class="sd">            C_cv: capacitances between charge and voltage nodes.</span>
<span class="sd">            db_name: name of database to store synthetic data.</span>
<span class="sd">            db_folder: path to folder where database is located.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">charge_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">charge_nodes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="k">if</span> <span class="n">voltage_nodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">voltage_nodes</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">db_name</span> <span class="o">=</span> <span class="n">db_name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">db_folder</span> <span class="o">=</span> <span class="n">db_folder</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_l</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_r</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">charge_nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">charge_nodes</span><span class="p">)])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="n">c_nodes</span> <span class="o">=</span> <span class="n">ChannelList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;charge_nodes&quot;</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">snapshotable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">v_nodes</span> <span class="o">=</span> <span class="n">ChannelList</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;voltage_nodes&quot;</span><span class="p">,</span> <span class="n">Node</span><span class="p">,</span> <span class="n">snapshotable</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nm</span><span class="p">,</span> <span class="n">vl</span> <span class="ow">in</span> <span class="n">charge_nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="s2">&quot;chargenode</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="s2">&quot;dot </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span>
                <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                <span class="n">node_type</span><span class="o">=</span><span class="s2">&quot;charge&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">c_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_submodule</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">nm</span><span class="p">,</span> <span class="n">vl</span> <span class="ow">in</span> <span class="n">voltage_nodes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">alias</span> <span class="o">=</span> <span class="s2">&quot;voltagenode</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">vl</span> <span class="o">+</span> <span class="s2">&quot; (V[</span><span class="si">{}</span><span class="s2">])&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nm</span><span class="p">)</span>
            <span class="n">node</span> <span class="o">=</span> <span class="n">Node</span><span class="p">(</span>
                <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
                <span class="n">name</span><span class="o">=</span><span class="n">alias</span><span class="p">,</span>
                <span class="n">label</span><span class="o">=</span><span class="n">label</span><span class="p">,</span>
                <span class="n">node_type</span><span class="o">=</span><span class="s2">&quot;voltage&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">v_nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_submodule</span><span class="p">(</span><span class="n">alias</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_submodule</span><span class="p">(</span><span class="s2">&quot;charge_nodes&quot;</span><span class="p">,</span> <span class="n">c_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_submodule</span><span class="p">(</span><span class="s2">&quot;voltage_nodes&quot;</span><span class="p">,</span> <span class="n">v_nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">C_cv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">C_cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voltage_nodes</span><span class="p">)])</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">C_cc_off_diags</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">C_cc_off_diags</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">off_diag_inx</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)):</span>
                <span class="n">C_cc_off_diags</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mf">0.0</span><span class="p">])</span>  <span class="c1"># type: ignore</span>

        <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s2">&quot;N&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;charge configuration&quot;</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">get_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_N</span><span class="p">,</span>
            <span class="n">set_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_N</span><span class="p">,</span>
            <span class="n">initial_value</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">V_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V_v</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voltage_nodes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s2">&quot;V_v&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;voltage configuration&quot;</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">get_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_V_v</span><span class="p">,</span>
            <span class="n">set_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_V_v</span><span class="p">,</span>
            <span class="n">initial_value</span><span class="o">=</span><span class="n">V_v</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s2">&quot;C_cv&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;gate capacitances&quot;</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">,</span>
            <span class="n">get_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_C_cv</span><span class="p">,</span>
            <span class="n">set_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_C_cv</span><span class="p">,</span>
            <span class="n">initial_value</span><span class="o">=</span><span class="n">C_cv</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s2">&quot;C_cc&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;dot capacitances&quot;</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">,</span>
            <span class="n">get_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_C_cc</span><span class="p">,</span>
            <span class="n">set_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_C_cc</span><span class="p">,</span>
            <span class="n">initial_value</span><span class="o">=</span><span class="n">C_cc_off_diags</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s2">&quot;c_r&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;capacitance to right lead&quot;</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">,</span>
            <span class="n">get_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_c_r</span><span class="p">,</span>
            <span class="n">set_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_c_r</span><span class="p">,</span>
            <span class="n">initial_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">add_parameter</span><span class="p">(</span>
            <span class="s2">&quot;c_l&quot;</span><span class="p">,</span>
            <span class="n">label</span><span class="o">=</span><span class="s2">&quot;capacitance to left lead&quot;</span><span class="p">,</span>
            <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">,</span>
            <span class="n">get_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_c_l</span><span class="p">,</span>
            <span class="n">set_cmd</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_set_c_l</span><span class="p">,</span>
            <span class="n">initial_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

<div class="viewcode-block" id="CapacitanceModel.snapshot_base"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.snapshot_base">[docs]</a>    <span class="k">def</span> <span class="nf">snapshot_base</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">params_to_skip_update</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Pass on QCoDeS snapshot.&quot;&quot;&quot;</span>
        <span class="n">snap</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">snapshot_base</span><span class="p">(</span><span class="n">update</span><span class="p">,</span> <span class="n">params_to_skip_update</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">snap</span></div>

<div class="viewcode-block" id="CapacitanceModel.set_voltage"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.set_voltage">[docs]</a>    <span class="k">def</span> <span class="nf">set_voltage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">n_index</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">node_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;voltage&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convenience method to set voltages.</span>

<span class="sd">        Args:</span>
<span class="sd">            n_index: Index of node to set.</span>
<span class="sd">            value: Value to set.</span>
<span class="sd">            node_type: Which node type to set, either &#39;voltage&#39; or</span>
<span class="sd">                &#39;charge&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s2">&quot;voltage&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">n_index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voltage_nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">voltage_nodes</span><span class="p">[</span><span class="n">n_index</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">node_type</span> <span class="o">==</span> <span class="s2">&quot;charge&quot;</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">n_index</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">n_index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">[</span><span class="n">n_index</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unknown node type. Cannot set voltage.&quot;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="CapacitanceModel.set_capacitance"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.set_capacitance">[docs]</a>    <span class="k">def</span> <span class="nf">set_capacitance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">which_matrix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">indices</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Convenience function to set capacitances.</span>

<span class="sd">        Args:</span>
<span class="sd">            which_matrix: String identifier of matrix to set.</span>
<span class="sd">                Either &#39;cv&#39; or &#39;cc&#39;.</span>
<span class="sd">            indices: Indices of capacitances within the matrix.</span>
<span class="sd">            value: Capacitance value to set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">which_matrix</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;cv&quot;</span><span class="p">,</span> <span class="s2">&quot;cc&quot;</span><span class="p">]:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;Unable to set capacitance. Unknown matrix,&quot;</span>
                <span class="o">+</span> <span class="s1">&#39;choose either &quot;cv&quot; or &quot;cc&quot;.&#39;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">which_matrix</span> <span class="o">==</span> <span class="s2">&quot;cc&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;CapacitanceModel: Trying to set diagonals &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;of C_cc matrix which is not possible &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;directly. They are determined by other &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;capacitances of the model.&quot;</span>
                <span class="p">)</span>
            <span class="n">C_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_cc</span><span class="p">()</span>
            <span class="n">C_cc</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C_cc</span><span class="p">(</span><span class="n">C_cc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">which_matrix</span> <span class="o">==</span> <span class="s2">&quot;cv&quot;</span><span class="p">:</span>
            <span class="n">C_cv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C_cv</span><span class="p">()</span>
            <span class="n">C_cv</span><span class="p">[</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">indices</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">C_cv</span><span class="p">(</span><span class="n">C_cv</span><span class="p">)</span></div>

<div class="viewcode-block" id="CapacitanceModel.set_Ccv_from_voltage_distance"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.set_Ccv_from_voltage_distance">[docs]</a>    <span class="k">def</span> <span class="nf">set_Ccv_from_voltage_distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">voltage_node_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">dV</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">charge_node_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Implements relation between voltage differences and capacitances</span>
<span class="sd">        between charge and voltage nodes.</span>

<span class="sd">        Args:</span>
<span class="sd">            voltage_node_idx: Voltage node index.</span>
<span class="sd">            dV: Voltage difference between two charge transitions.</span>
<span class="sd">            charge_node_idx: Charge node index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">capa_val</span> <span class="o">=</span> <span class="o">-</span><span class="n">elem_charge</span> <span class="o">*</span> <span class="n">dV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_capacitance</span><span class="p">(</span>
            <span class="s2">&quot;cv&quot;</span><span class="p">,</span>
            <span class="p">[</span><span class="n">charge_node_idx</span><span class="p">,</span> <span class="n">voltage_node_idx</span><span class="p">],</span>
            <span class="n">capa_val</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="CapacitanceModel.compute_energy"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.compute_energy">[docs]</a>    <span class="k">def</span> <span class="nf">compute_energy</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">V_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Computes the total energy of the dot system.</span>

<span class="sd">        Args:</span>
<span class="sd">            N: charge configuration, i.e. number of charges on each</span>
<span class="sd">                charge node.</span>
<span class="sd">            V_v: Voltages to set on voltages nodes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: energy of the system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">()</span>
            <span class="n">N_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">N_self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">V_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">()</span>

        <span class="n">C_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C_cc</span><span class="p">())</span>
        <span class="n">C_cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C_cv</span><span class="p">())</span>

        <span class="n">U</span> <span class="o">=</span> <span class="p">(</span><span class="n">elem_charge</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">multi_dot</span><span class="p">([</span><span class="n">N_np</span><span class="p">,</span> <span class="n">inv</span><span class="p">(</span><span class="n">C_cc</span><span class="p">),</span> <span class="n">N_np</span><span class="p">])</span>
        <span class="n">U</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">multi_dot</span><span class="p">([</span><span class="n">V_v</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">C_cv</span><span class="p">),</span> <span class="n">inv</span><span class="p">(</span><span class="n">C_cc</span><span class="p">),</span> <span class="n">C_cv</span><span class="p">,</span> <span class="n">V_v</span><span class="p">])</span>
        <span class="n">U</span> <span class="o">+=</span> <span class="n">elem_charge</span> <span class="o">*</span> <span class="n">multi_dot</span><span class="p">([</span><span class="n">N_np</span><span class="p">,</span> <span class="n">inv</span><span class="p">(</span><span class="n">C_cc</span><span class="p">),</span> <span class="n">C_cv</span><span class="p">,</span> <span class="n">V_v</span><span class="p">])</span>

        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">U</span><span class="p">)</span></div>

<div class="viewcode-block" id="CapacitanceModel.determine_N"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.determine_N">[docs]</a>    <span class="k">def</span> <span class="nf">determine_N</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">V_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Determines the charge state N by minimizing the total</span>
<span class="sd">        energy of the dot system.</span>

<span class="sd">        Args:</span>
<span class="sd">            V_v: Voltages to set on voltages nodes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: Charge state, i.e. number of electrons on each charge node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">V_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">()</span>

        <span class="n">eng_fct</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">())</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
            <span class="n">eng_fct</span><span class="p">,</span>
            <span class="n">x0</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">c_config</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">x</span><span class="p">)</span>

        <span class="n">n_dots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">c_config</span><span class="p">)</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">c_configs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">current_energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">c_config</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">append_energy</span><span class="p">(</span><span class="n">charge_stage</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">charge_stage</span><span class="p">[</span><span class="n">charge_stage</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># type: ignore</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">charge_stage</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">))</span>
            <span class="n">c_configs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">charge_stage</span><span class="p">)</span>

        <span class="n">I_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_dots</span><span class="p">)</span>
        <span class="c1"># Check if neighbouring ones have lower energy:</span>
        <span class="k">for</span> <span class="n">dot_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>
            <span class="n">e_hat</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">dot_id</span><span class="p">]</span>

            <span class="n">append_energy</span><span class="p">(</span><span class="n">c_config</span> <span class="o">+</span> <span class="n">e_hat</span><span class="p">)</span>
            <span class="n">append_energy</span><span class="p">(</span><span class="n">c_config</span> <span class="o">-</span> <span class="n">e_hat</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">other_dot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">other_dot</span> <span class="o">!=</span> <span class="n">dot_id</span><span class="p">:</span>
                    <span class="n">e_hat_other</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">other_dot</span><span class="p">]</span>
                    <span class="n">append_energy</span><span class="p">(</span><span class="n">c_config</span> <span class="o">+</span> <span class="n">e_hat</span> <span class="o">-</span> <span class="n">e_hat_other</span><span class="p">)</span>

        <span class="n">indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">current_energy</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">indx</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">min_indx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">energies</span><span class="p">)[</span><span class="n">indx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)])</span>
            <span class="n">min_c_configs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c_configs</span><span class="p">)[</span><span class="n">indx</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)]</span>
            <span class="n">c_config</span> <span class="o">=</span> <span class="n">min_c_configs</span><span class="p">[</span><span class="n">min_indx</span><span class="p">]</span>

        <span class="n">c_config</span><span class="p">[</span><span class="n">c_config</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">c_config</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span></div>

<div class="viewcode-block" id="CapacitanceModel.get_triplepoints"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.get_triplepoints">[docs]</a>    <span class="k">def</span> <span class="nf">get_triplepoints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">voltage_node_idx</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">N_limits</span><span class="p">:</span> <span class="n">N_lmt_type</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
            <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]:</span>
        <span class="sd">&quot;&quot;&quot;Calculates triple points for charge configurations within</span>
<span class="sd">        &#39;N_limits&#39;.</span>

<span class="sd">        Args:</span>
<span class="sd">            voltage_node_idx: indices of gates to sweep</span>
<span class="sd">            N_limit: Min and max values of number of electrons in each dot,</span>
<span class="sd">                     defining all charge configurations to consider</span>

<span class="sd">        Return:</span>
<span class="sd">            np.array: Coordinates of electron triple points</span>
<span class="sd">            np.array: Coordinates of hole triple points</span>
<span class="sd">            list: List of electron charge configurations</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">N_limits</span><span class="p">)</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">()):</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;CapacitanceModel.get_triplepoints: &quot;</span>
                <span class="o">+</span> <span class="s2">&quot;Infeasible charge configuration supplied.&quot;</span>
            <span class="p">)</span>

        <span class="n">c_configs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n_vals</span> <span class="ow">in</span> <span class="n">N_limits</span><span class="p">:</span>
            <span class="n">c_configs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">n_vals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n_vals</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>

        <span class="n">c_configs</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">c_configs</span><span class="p">)]</span>

        <span class="n">coordinates_etp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c_configs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">)])</span>
        <span class="n">coordinates_htp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">c_configs</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">)])</span>

        <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">c_config</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">c_configs</span><span class="p">):</span>
            <span class="c1"># setting N mostly for monitor purposes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">c_config</span><span class="p">))</span>
            <span class="n">x_etp</span><span class="p">,</span> <span class="n">x_htp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_triplepoints</span><span class="p">(</span>
                <span class="n">voltage_node_idx</span><span class="p">,</span> <span class="n">c_config</span>
            <span class="p">)</span>

            <span class="n">coordinates_etp</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_etp</span>
            <span class="n">coordinates_htp</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">=</span> <span class="n">x_htp</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates_etp</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates_htp</span><span class="p">),</span> <span class="n">c_configs</span></div>

<div class="viewcode-block" id="CapacitanceModel.calculate_triplepoints"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.calculate_triplepoints">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_triplepoints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">voltage_node_idx</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">N</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Determines coordinates in voltage space of triple points</span>
<span class="sd">        (electron and hole) for a single charge configuration.</span>

<span class="sd">        Args:</span>
<span class="sd">            voltage_node_idx: Indices of voltage nodes to be determined</span>
<span class="sd">            N: Charge configuration, number of electrons of each charge</span>
<span class="sd">                node.</span>

<span class="sd">        Return:</span>
<span class="sd">            np.array: Coordinates of electron triple points.</span>
<span class="sd">            np.array: Coordinates of hole triple points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">e_tp</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu_electron_triplepoints</span><span class="p">,</span>
            <span class="n">voltage_node_idx</span><span class="o">=</span><span class="n">voltage_node_idx</span><span class="p">,</span>
            <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">h_tp</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mu_hole_triplepoints</span><span class="p">,</span>
            <span class="n">voltage_node_idx</span><span class="o">=</span><span class="n">voltage_node_idx</span><span class="p">,</span>
            <span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">x_init</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">())[</span><span class="n">voltage_node_idx</span><span class="p">]</span>

        <span class="n">x_etp</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span><span class="n">e_tp</span><span class="p">,</span> <span class="n">x_init</span><span class="p">)</span>
        <span class="n">x_htp</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">fsolve</span><span class="p">(</span><span class="n">h_tp</span><span class="p">,</span> <span class="n">x_init</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">x_etp</span><span class="p">,</span> <span class="n">x_htp</span></div>

<div class="viewcode-block" id="CapacitanceModel.mu_electron_triplepoints"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.mu_electron_triplepoints">[docs]</a>    <span class="k">def</span> <span class="nf">mu_electron_triplepoints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_voltages</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">voltage_node_idx</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">N</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Calculates chemical potentials of all charge nodes</span>
<span class="sd">        for a given charge configuration N and corresponding to electron</span>
<span class="sd">        triple points (:math:`\mu(N)`).</span>

<span class="sd">        Args:</span>
<span class="sd">            new_voltages: Voltages to set on voltage nodes.</span>
<span class="sd">            voltage_node_idx: Voltage node indices to which the values</span>
<span class="sd">                in new_voltages correspond to.</span>
<span class="sd">            N: Desired charge configuration, optional. If none supplied</span>
<span class="sd">                self.N() is taken.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.array: Chemical potentials of electron triple points</span>
<span class="sd">                corresponding to electron triple points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">()</span>

        <span class="n">V_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">()</span>
        <span class="n">V_v</span><span class="p">[</span><span class="n">voltage_node_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_voltages</span>

        <span class="n">I_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>

        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">dot_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">)):</span>
            <span class="n">e_hat</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">dot_id</span><span class="p">]</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="n">dot_id</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span> <span class="o">+</span> <span class="n">e_hat</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>

<div class="viewcode-block" id="CapacitanceModel.mu_hole_triplepoints"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.mu_hole_triplepoints">[docs]</a>    <span class="k">def</span> <span class="nf">mu_hole_triplepoints</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">new_voltages</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">voltage_node_idx</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">N</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Calculates chemical potentials of all charge nodes</span>
<span class="sd">            for given charge configuration N and corresponding to hole triple</span>
<span class="sd">            points (:math:`mu_{j}(N + \hat{e}_{i})`).</span>

<span class="sd">        Args:</span>
<span class="sd">            new_voltages: values of new gate voltages, to be replaced in</span>
<span class="sd">                self.V_v. These are the values scipy.optimize.fsolve is solving</span>
<span class="sd">                for.</span>
<span class="sd">            voltage_node_idx: Voltages nodes indices to which the values</span>
<span class="sd">                above correspond to.</span>
<span class="sd">            N: Desired charge configuration, if none supplied self.N() is taken.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">()</span>
        <span class="n">V_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">()</span>
        <span class="n">V_v</span><span class="p">[</span><span class="n">voltage_node_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_voltages</span>

        <span class="n">I_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">))</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">dot_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">)):</span>
            <span class="n">e_hat</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">dot_id</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">other_dot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">other_dot</span> <span class="o">!=</span> <span class="n">dot_id</span><span class="p">:</span>
                    <span class="n">e_hat_other</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">other_dot</span><span class="p">]</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="n">dot_id</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N</span> <span class="o">+</span> <span class="n">e_hat_other</span> <span class="o">+</span> <span class="n">e_hat</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">)</span>
                    <span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span></div>

<div class="viewcode-block" id="CapacitanceModel.mu"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.mu">[docs]</a>    <span class="k">def</span> <span class="nf">mu</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">dot_indx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">N</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">V_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculates the chemical potential of a single dot (charge node)</span>
<span class="sd">        given the charge</span>
<span class="sd">        and voltage configuration of the entire dot system (all dots included).</span>

<span class="sd">        Args:</span>
<span class="sd">            dot_indx: index of dot for which the chemical potential should be</span>
<span class="sd">                computed.</span>
<span class="sd">            N: Charge configuration of the entire system, i.e. the number of</span>
<span class="sd">                electrons on each charge node.</span>
<span class="sd">            V_v: Voltages to set on (all) voltage nodes.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Chemical potential of dot `dot_indx`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">N</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">N_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">V_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V_v_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">V_v_np</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">V_v</span><span class="p">)</span>

        <span class="n">C_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C_cc</span><span class="p">())</span>
        <span class="n">C_cv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C_cv</span><span class="p">())</span>

        <span class="n">e_hat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N_np</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">e_hat</span><span class="p">[</span><span class="n">dot_indx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">pot</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">elem_charge</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">multi_dot</span><span class="p">([</span><span class="n">e_hat</span><span class="p">,</span> <span class="n">inv</span><span class="p">(</span><span class="n">C_cc</span><span class="p">),</span> <span class="n">e_hat</span><span class="p">])</span>
        <span class="n">pot</span> <span class="o">+=</span> <span class="p">(</span><span class="n">elem_charge</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="n">multi_dot</span><span class="p">([</span><span class="n">N_np</span><span class="p">,</span> <span class="n">inv</span><span class="p">(</span><span class="n">C_cc</span><span class="p">),</span> <span class="n">e_hat</span><span class="p">])</span>
        <span class="n">pot</span> <span class="o">+=</span> <span class="n">elem_charge</span> <span class="o">*</span> <span class="n">multi_dot</span><span class="p">([</span><span class="n">e_hat</span><span class="p">,</span> <span class="n">inv</span><span class="p">(</span><span class="n">C_cc</span><span class="p">),</span> <span class="n">C_cv</span><span class="p">,</span> <span class="n">V_v_np</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">pot</span></div>

<div class="viewcode-block" id="CapacitanceModel.sweep_voltages"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.sweep_voltages">[docs]</a>    <span class="k">def</span> <span class="nf">sweep_voltages</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">voltage_node_idx</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>  <span class="c1"># the one we want to sweep</span>
        <span class="n">voltage_ranges</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span>
        <span class="n">n_steps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">N_2D</span><span class="p">,</span>
        <span class="n">line_intensity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">add_noise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">target_snr_db</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">known_regime</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;doubledot&#39;</span><span class="p">,</span>
        <span class="n">known_quality</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">add_charge_jumps</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">jump_freq</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Sweep two voltage nodes to measure a charge diagram.</span>
<span class="sd">        Calculate current at zero bias and at zero temperature.</span>
<span class="sd">        Random normal noise and charge jumps can be added</span>
<span class="sd">        optionally as well. The diagram is saved into .db using QCoDeS.</span>

<span class="sd">        Args:</span>
<span class="sd">            voltage_node_idx: Voltage node indices to sweep.</span>
<span class="sd">            voltage_ranges: Voltage ranges to sweep.</span>
<span class="sd">            n_steps: Number of steps of the measurement.</span>
<span class="sd">            line_intensity: Multiplication factor of transport current.</span>
<span class="sd">                It depends on number of degeneracies and coupling strength between</span>
<span class="sd">                dots and leads.</span>
<span class="sd">            add_noise: whether or not to add noise.</span>
<span class="sd">            broadening: level broadening due to dots coupling to leads</span>
<span class="sd">            target_snr_db: Target signal-to-noise ratio used to</span>
<span class="sd">                calculate amplitude of random normal noise.</span>
<span class="sd">            normalize: whether to normalize the data.</span>
<span class="sd">            known_regime: Label to be saved in metadata.</span>
<span class="sd">            known_quality: Quality to be saved in metadata.</span>
<span class="sd">            add_charge_jumps: Whether or not to add random charge jumps.</span>
<span class="sd">            jump_freq: Average frequency at which optional charge jumps</span>
<span class="sd">                should occur.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: QCoDeS data run ID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_voltage</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voltage_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_voltage</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voltage_ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

        <span class="n">voltage_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voltage_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">voltage_ranges</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">n_steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">voltage_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voltage_ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">voltage_ranges</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">n_steps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">add_charge_jumps</span><span class="p">:</span>
            <span class="n">additional_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">poisson</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">poisson</span><span class="p">(</span><span class="n">lam</span><span class="o">=</span><span class="n">jump_freq</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">n_steps</span><span class="p">)</span>
            <span class="n">poisson</span><span class="p">[</span><span class="n">poisson</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="k">for</span> <span class="n">iy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_steps</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">poisson</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">s</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
                    <span class="n">additional_charges</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">]</span> <span class="o">*=</span> <span class="n">s</span>
            <span class="n">additional_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">additional_charges</span><span class="p">)</span>
            <span class="n">additional_charges</span> <span class="o">=</span> <span class="p">(</span><span class="n">additional_charges</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">additional_charges</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">ivx</span><span class="p">,</span> <span class="n">x_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">voltage_x</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_voltage</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">voltage_y</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_voltage</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_val</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">ivy</span><span class="p">,</span> <span class="n">y_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">voltage_y</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_voltage</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_val</span><span class="p">)</span>

                <span class="n">N_curr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_N</span><span class="p">()</span>
                <span class="n">n_idx</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N_curr</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                <span class="n">N_curr</span><span class="p">[</span><span class="n">n_idx</span><span class="p">]</span> <span class="o">+=</span> <span class="n">additional_charges</span><span class="p">[</span><span class="n">ivx</span><span class="p">,</span> <span class="n">ivy</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">(</span><span class="n">N_curr</span><span class="p">)</span>

                <span class="n">signal</span><span class="p">[</span><span class="n">ivx</span><span class="p">,</span> <span class="n">ivy</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_transport_at_zero_bias</span><span class="p">(</span>
                    <span class="n">N_current</span><span class="o">=</span><span class="n">N_curr</span><span class="p">,</span>
                <span class="p">)</span> <span class="o">*</span> <span class="n">line_intensity</span>

        <span class="k">if</span> <span class="n">add_noise</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_noise</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">target_snr_db</span><span class="o">=</span><span class="n">target_snr_db</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">known_quality</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">target_snr_db</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">quality</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">quality</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">quality</span> <span class="o">=</span> <span class="n">known_quality</span>

        <span class="n">dataid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_to_db</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">voltage_nodes</span><span class="p">[</span><span class="n">voltage_node_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">v</span><span class="p">,</span>
             <span class="bp">self</span><span class="o">.</span><span class="n">voltage_nodes</span><span class="p">[</span><span class="n">voltage_node_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">v</span><span class="p">],</span>
            <span class="p">[</span><span class="n">voltage_x</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">voltage_y</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span>
            <span class="n">signal</span><span class="p">,</span>
            <span class="n">nt_label</span><span class="o">=</span><span class="p">[</span><span class="n">known_regime</span><span class="p">],</span>
            <span class="n">quality</span><span class="o">=</span><span class="n">quality</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">dataid</span></div>

<div class="viewcode-block" id="CapacitanceModel.sweep_voltage"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.sweep_voltage">[docs]</a>    <span class="k">def</span> <span class="nf">sweep_voltage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">voltage_node_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">voltage_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">n_steps</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">N_1D</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">line_intensity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">add_noise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">broadening</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span>
        <span class="n">target_snr_db</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">100.0</span><span class="p">,</span>
        <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Sweep one voltage to measure Coulomb oscillations.</span>
<span class="sd">        Calculate current at zero bias and at zero temperature. Random normal noise</span>
<span class="sd">        and charge jumps can be added optionally as well. The diagram is</span>
<span class="sd">        saved into .db using QCoDeS.</span>

<span class="sd">        Args:</span>
<span class="sd">            voltage_node_idx: voltage node index to sweep.</span>
<span class="sd">            voltage_range: Voltage range to sweep.</span>
<span class="sd">            n_steps: Number of steps of the measurement.</span>
<span class="sd">            line_intensity: Multiplication factor of transport current.</span>
<span class="sd">                It depends on number of degeneracies and coupling strength between</span>
<span class="sd">                dots and leads.</span>
<span class="sd">            add_noise: whether or not to add noise.</span>
<span class="sd">            broadening: level broadening due to dots coupling to leads</span>
<span class="sd">            target_snr_db: target signal-to-noise ratio used to</span>
<span class="sd">                calculate amplitude of random normal noise.</span>
<span class="sd">            normalize: whether to normalize the data.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: QCoDeS data run ID.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_voltage</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voltage_range</span><span class="p">))</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span>

        <span class="n">voltage_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voltage_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">voltage_range</span><span class="p">),</span> <span class="n">n_steps</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">v_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">voltage_x</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_voltage</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">,</span> <span class="n">v_val</span><span class="p">)</span>
            <span class="n">N_current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_N</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">(</span><span class="n">N_current</span><span class="p">)</span>

            <span class="n">signal</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calculate_transport_at_zero_bias</span><span class="p">(</span>
                <span class="n">N_current</span><span class="o">=</span><span class="n">N_current</span><span class="p">,</span> <span class="n">broadening</span><span class="o">=</span><span class="n">broadening</span><span class="p">)</span> <span class="o">*</span> <span class="n">line_intensity</span>

        <span class="k">if</span> <span class="n">add_noise</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_add_noise</span><span class="p">(</span><span class="n">signal</span><span class="p">,</span> <span class="n">target_snr_db</span><span class="o">=</span><span class="n">target_snr_db</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">signal</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>

        <span class="n">dataid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_save_to_db</span><span class="p">(</span>
            <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">voltage_nodes</span><span class="p">[</span><span class="n">voltage_node_idx</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">],</span>
            <span class="p">[</span><span class="n">voltage_x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()],</span>
            <span class="n">signal</span><span class="p">,</span>
            <span class="n">nt_label</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;coulomboscillation&quot;</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">dataid</span></div>

<div class="viewcode-block" id="CapacitanceModel.sweep_bias_and_voltage"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.sweep_bias_and_voltage">[docs]</a>    <span class="k">def</span> <span class="nf">sweep_bias_and_voltage</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">voltage_node_idx</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>  <span class="c1"># the one we want to sweep</span>
        <span class="n">voltage_range</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span>
        <span class="n">bias_range</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">n_steps</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">N_2D</span><span class="p">,</span>
        <span class="n">line_intensity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Computes a Coulomb diamond diagram by sweeping the source-drain</span>
<span class="sd">        bias against a voltage. It returns two diagrams, one showing</span>
<span class="sd">        the bias-voltage sweep without co-tunneling events and a second</span>
<span class="sd">        showing elastic co-tunneling events only, calculated via</span>
<span class="sd">        `get_co_tunneling_rate`.</span>

<span class="sd">        Args:</span>
<span class="sd">            voltage_node_idx: voltage node index to sweep.</span>
<span class="sd">            voltage_range: range of voltage to sweep.</span>
<span class="sd">            bias_range: bias range to sweep.</span>
<span class="sd">            n_steps: number of steps in each dimension.</span>
<span class="sd">            line_intensity: Multiplication factor of number of</span>
<span class="sd">                degeneracies, resulting in the desired peak hight before normalization.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.ndarray: 2d diagram of bias-voltage sweep without tunneling</span>
<span class="sd">                events.</span>
<span class="sd">            np.ndarray: 2d diagram showing elastic co-tunneling only.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_voltage</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voltage_range</span><span class="p">))</span>

        <span class="n">voltage_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">voltage_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">voltage_range</span><span class="p">),</span> <span class="n">n_steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="p">)</span>

        <span class="n">bias_steps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">bias_range</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">bias_range</span><span class="p">),</span> <span class="n">n_steps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">signal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span>
        <span class="n">co_tunn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">n_steps</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">v_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">voltage_x</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_voltage</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">,</span> <span class="n">v_val</span><span class="p">)</span>
            <span class="n">N_current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">determine_N</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">(</span><span class="n">N_current</span><span class="p">)</span>

            <span class="n">dU</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_energy_differences_to_excited_charge_states</span><span class="p">(</span>
                <span class="n">N_current</span><span class="o">=</span><span class="n">N_current</span><span class="p">,</span>
                <span class="n">n_diff_charges</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">ib</span><span class="p">,</span> <span class="n">b_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bias_steps</span><span class="p">):</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">dU</span> <span class="o">&lt;=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b_val</span><span class="p">))</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                    <span class="n">signal</span><span class="p">[</span><span class="n">iv</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">=</span> <span class="n">line_intensity</span>
                    <span class="n">engs_in_bias</span> <span class="o">=</span> <span class="n">dU</span><span class="p">[</span><span class="n">dU</span> <span class="o">&lt;=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">b_val</span><span class="p">)]</span>
                    <span class="c1"># signal[iv, ib] = np.sum(np.reciprocal(engs_in_bias)) * line_intensity</span>
                    <span class="n">signal</span><span class="p">[</span><span class="n">iv</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">engs_in_bias</span><span class="p">)</span> <span class="o">*</span> <span class="n">line_intensity</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">signal</span><span class="p">[</span><span class="n">iv</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="n">N_plus_one</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">N_current</span><span class="p">)</span>
                    <span class="n">N_plus_one</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">N_plus_one</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">1.</span>  <span class="c1"># type: ignore</span>
                    <span class="n">add_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_co_tunneling_rate</span><span class="p">(</span>
                        <span class="n">b_val</span><span class="p">,</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N_current</span><span class="p">),</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N_plus_one</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="n">co_tunn</span><span class="p">[</span><span class="n">iv</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">+=</span> <span class="n">add_rate</span>

        <span class="n">signal</span> <span class="o">=</span> <span class="p">(</span><span class="n">signal</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">signal</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">signal</span><span class="p">)</span>
        <span class="n">co_tunn</span> <span class="o">=</span> <span class="p">(</span><span class="n">co_tunn</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">co_tunn</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">co_tunn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">signal</span><span class="p">,</span> <span class="n">co_tunn</span></div>

<div class="viewcode-block" id="CapacitanceModel.get_co_tunneling_rate"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.get_co_tunneling_rate">[docs]</a>    <span class="k">def</span> <span class="nf">get_co_tunneling_rate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">bias</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">mu_n</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">mu_n_plus_one</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">source_rate_N</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="n">source_rate_N_plus_one</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">drain_rate_N</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.3</span><span class="p">,</span>
        <span class="n">drain_rate_N_plus_one</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
        <span class="n">h_bar</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Calculates the elastic co-tunneling rate according to the equation</span>
<span class="sd">        on page 400 (chapter 8) or Thomas Ihn&#39;s book. This equations assumes</span>
<span class="sd">        the system to be at zero temperature and that tunneling rates are</span>
<span class="sd">        independent of energy over a small source-drain voltage.</span>

<span class="sd">        Args:</span>
<span class="sd">            bias: source drain bias</span>
<span class="sd">            mu_n: chemical potential of charge state with a total of N charges,</span>
<span class="sd">                e.g. of the self.N() state.</span>
<span class="sd">            mu_n_plus_one: chemical potential of charge state with N+1 charges,</span>
<span class="sd">                e.g. an adjacent charge state of self.N(). Adjacent means</span>
<span class="sd">                having one additional charge.</span>
<span class="sd">            source_rate_N: tunneling rate between source and a dot system in</span>
<span class="sd">                charge state with a total of N charges.</span>
<span class="sd">            source_rate_N_plus_one: tunneling rate between source and a dot</span>
<span class="sd">                system in charge state with a total of N+1 charges.</span>
<span class="sd">            drain_rate_N: tunneling rate between drain and a dot system in</span>
<span class="sd">                charge state with a total of N charges</span>
<span class="sd">            drain_rate_N_plus_one: tunneling rate between drain and a dot</span>
<span class="sd">                system in charge state with a total of N+1 charges.</span>
<span class="sd">            h_bar: Plank constant or the substitution thereof.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: co-tunneling rate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mu_source</span> <span class="o">=</span> <span class="n">bias</span>
        <span class="n">mu_drain</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="n">first_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_rate_N</span> <span class="o">*</span> <span class="n">drain_rate_N</span><span class="p">)</span>
        <span class="n">first_term</span> <span class="o">/=</span> <span class="p">((</span><span class="n">mu_drain</span> <span class="o">-</span> <span class="n">mu_n</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">mu_source</span> <span class="o">-</span> <span class="n">mu_n</span><span class="p">))</span>
        <span class="n">second_term</span> <span class="o">=</span> <span class="p">(</span><span class="n">source_rate_N_plus_one</span> <span class="o">*</span> <span class="n">drain_rate_N_plus_one</span><span class="p">)</span>
        <span class="n">second_term</span> <span class="o">/=</span> <span class="p">((</span><span class="n">mu_drain</span> <span class="o">-</span> <span class="n">mu_n_plus_one</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">mu_source</span> <span class="o">-</span> <span class="n">mu_n_plus_one</span><span class="p">))</span>
        <span class="n">third_term</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">mu_n_plus_one</span> <span class="o">-</span> <span class="n">mu_drain</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu_drain</span> <span class="o">-</span> <span class="n">mu_n</span><span class="p">))</span>
        <span class="n">third_term</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">((</span><span class="n">mu_n_plus_one</span> <span class="o">-</span> <span class="n">mu_source</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">mu_source</span> <span class="o">-</span> <span class="n">mu_n</span><span class="p">))</span>
        <span class="n">third_term</span> <span class="o">/=</span> <span class="p">((</span><span class="n">mu_n_plus_one</span> <span class="o">-</span> <span class="n">mu_n</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">mu_source</span> <span class="o">-</span> <span class="n">mu_drain</span><span class="p">))</span>

        <span class="n">co_tunneling_rate</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">h_bar</span> <span class="o">*</span> <span class="p">(</span><span class="n">first_term</span> <span class="o">+</span> <span class="n">second_term</span><span class="p">)</span> <span class="o">*</span> <span class="n">bias</span>
        <span class="n">co_tunneling_rate</span> <span class="o">+=</span> <span class="n">third_term</span>

        <span class="k">return</span> <span class="n">co_tunneling_rate</span></div>

<div class="viewcode-block" id="CapacitanceModel.calculate_transport_at_zero_bias"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.calculate_transport_at_zero_bias">[docs]</a>    <span class="k">def</span> <span class="nf">calculate_transport_at_zero_bias</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
        <span class="n">N_current</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">V_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">broadening</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.01</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Computes transport signal at zero bias and at zero temperature.</span>

<span class="sd">        Assume the electrochemical potentials of source and drain to be zero (zero bias)</span>
<span class="sd">        Transport current is propotional to DOS (density of states) of all dot levels at energy 0</span>
<span class="sd">        Assume that all dots are connected sequentially, meaning carrier needs to hop from</span>
<span class="sd">        source to dot 1, then to dot 2, ..., then to dot N, and finally hop to drain</span>
<span class="sd">        In this case, current is propotional to (DOS of dot 1 at energy 0) * ... * (DOS of dot N at 0)</span>
<span class="sd">        For each dot, only consider current charge state and the first excited state.</span>
<span class="sd">        Also take into account level broadening due to dots coupling to leads.</span>

<span class="sd">        Args:</span>
<span class="sd">            N_current: charge state to which other states differing by at most</span>
<span class="sd">                one charge should be compared to. Default is self.N().</span>
<span class="sd">            V_v: voltage configuration at which the energies should be computed.</span>
<span class="sd">                Default is self.V_v().</span>
<span class="sd">            broadening: level broadening due to dots coupling to leads</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: transport signal in given configuration</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_dots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">N_current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N_current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">(</span><span class="n">N_current</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">V_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">(</span><span class="n">V_v</span><span class="p">)</span>

        <span class="n">I_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_dots</span><span class="p">)</span>
        <span class="n">current</span> <span class="o">=</span> <span class="mf">1.</span>

        <span class="k">for</span> <span class="n">dot_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>
            <span class="n">dos</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="n">e_hat</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">dot_id</span><span class="p">]</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="n">dot_id</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">N_current</span><span class="p">)</span>
            <span class="c1"># dos of current charge state</span>
            <span class="n">dos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lorentzian_density_of_state</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">broadening</span><span class="p">)</span>
            <span class="n">charge_state</span> <span class="o">=</span> <span class="n">N_current</span> <span class="o">+</span> <span class="n">e_hat</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="n">dot_id</span><span class="p">,</span> <span class="n">N</span><span class="o">=</span><span class="n">charge_state</span><span class="p">)</span>
            <span class="c1"># dos of the first excited state</span>
            <span class="n">dos</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lorentzian_density_of_state</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">mu</span><span class="p">,</span> <span class="n">broadening</span><span class="p">)</span>
            <span class="n">current</span> <span class="o">*=</span> <span class="n">dos</span>

        <span class="k">return</span> <span class="n">current</span></div>

<div class="viewcode-block" id="CapacitanceModel.lorentzian_density_of_state"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.lorentzian_density_of_state">[docs]</a>    <span class="k">def</span> <span class="nf">lorentzian_density_of_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">transport_energy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">level_energy</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">broadening</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Computes density of states of a energy level at given transport energy</span>
<span class="sd">        using a Lorentzian function</span>

<span class="sd">        For reference, see equation 1.3.2 in S. Datta&#39;s book</span>
<span class="sd">        Quantum Transport Atom To Transistor</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: density of state at transport energy</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diff</span> <span class="o">=</span> <span class="n">transport_energy</span> <span class="o">-</span> <span class="n">level_energy</span>
        <span class="k">return</span> <span class="n">broadening</span> <span class="o">/</span> <span class="p">(</span><span class="mf">2.</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">diff</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">broadening</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mf">4.</span><span class="p">))</span></div>

<div class="viewcode-block" id="CapacitanceModel.get_energy_differences_to_adjacent_charge_states"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.get_energy_differences_to_adjacent_charge_states">[docs]</a>    <span class="k">def</span> <span class="nf">get_energy_differences_to_adjacent_charge_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">N_current</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">V_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Computes energy differences between a charge state and all states</span>
<span class="sd">        differing from it by at most one charge.</span>

<span class="sd">        Args:</span>
<span class="sd">            N_current: charge state to which other states differing by at most</span>
<span class="sd">                one charge should be compared to. Default is self.N().</span>
<span class="sd">            V_v: voltage configuration at which the energies should be computed.</span>
<span class="sd">                Default is self.V_v().</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.array: Energy differences to charge states differing by at most</span>
<span class="sd">                one charge.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">n_dots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">N_current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N_current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">(</span><span class="n">N_current</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">V_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">(</span><span class="n">V_v</span><span class="p">)</span>

        <span class="n">I_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_dots</span><span class="p">)</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">dot_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>
            <span class="n">e_hat</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">dot_id</span><span class="p">]</span>

            <span class="n">charge_state</span> <span class="o">=</span> <span class="n">N_current</span> <span class="o">+</span> <span class="n">e_hat</span>
            <span class="n">charge_state</span><span class="p">[</span><span class="n">charge_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">charge_state</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">))</span>

            <span class="n">charge_state</span> <span class="o">=</span> <span class="n">N_current</span> <span class="o">-</span> <span class="n">e_hat</span>
            <span class="n">charge_state</span><span class="p">[</span><span class="n">charge_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">charge_state</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">other_dot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">other_dot</span> <span class="o">!=</span> <span class="n">dot_id</span><span class="p">:</span>
                    <span class="n">e_hat_other</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">other_dot</span><span class="p">]</span>
                    <span class="n">charge_state</span> <span class="o">=</span> <span class="n">N_current</span> <span class="o">+</span> <span class="n">e_hat</span> <span class="o">-</span> <span class="n">e_hat_other</span>
                    <span class="n">charge_state</span><span class="p">[</span><span class="n">charge_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span>
                            <span class="n">N</span><span class="o">=</span><span class="n">charge_state</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">,</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
        <span class="n">current_energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N_current</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">)</span>
        <span class="n">dU</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span> <span class="o">-</span> <span class="n">current_energy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dU</span><span class="p">[</span><span class="n">dU</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CapacitanceModel.get_energy_differences_to_excited_charge_states"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.get_energy_differences_to_excited_charge_states">[docs]</a>    <span class="k">def</span> <span class="nf">get_energy_differences_to_excited_charge_states</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">N_current</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">V_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">n_diff_charges</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Computes energy differences between a charge state and all states</span>
<span class="sd">        differing from it by at most &#39;n_diff_charges&#39; charges. These additional</span>
<span class="sd">        charges represent excited charge state which require an excitation</span>
<span class="sd">        voltage for a quantum dot system to reach them.</span>

<span class="sd">        Args:</span>
<span class="sd">            N_current: charge state to which other states differing by at most</span>
<span class="sd">                &#39;n_diff_charges&#39; charges should be compared to. Default is self.N().</span>
<span class="sd">            V_v: voltage configuration at which the energies should be computed.</span>
<span class="sd">                Default is self.V_v().</span>
<span class="sd">            n_diff_charges: number of extra charges to consider adding to</span>
<span class="sd">                &#39;N_current&#39;.</span>

<span class="sd">        Returns:</span>
<span class="sd">            np.array: Energy differences to charge states differing by at most</span>
<span class="sd">                &#39;n_diff_charges&#39; charges.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">n_dots</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">N_current</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N_current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">(</span><span class="n">N_current</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">V_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">(</span><span class="n">V_v</span><span class="p">)</span>

        <span class="n">I_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_dots</span><span class="p">)</span>
        <span class="n">energies</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">dot_id</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>
            <span class="n">e_hat</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">dot_id</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">add_e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_diff_charges</span><span class="p">):</span>
                <span class="n">charge_state</span> <span class="o">=</span> <span class="n">N_current</span> <span class="o">+</span> <span class="p">(</span><span class="n">add_e</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">e_hat</span>
                <span class="n">charge_state</span><span class="p">[</span><span class="n">charge_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">charge_state</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">))</span>

            <span class="n">charge_state</span> <span class="o">=</span> <span class="n">N_current</span> <span class="o">-</span> <span class="n">e_hat</span>
            <span class="n">charge_state</span><span class="p">[</span><span class="n">charge_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">charge_state</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">))</span>

            <span class="k">for</span> <span class="n">other_dot</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_dots</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">other_dot</span> <span class="o">!=</span> <span class="n">dot_id</span><span class="p">:</span>
                    <span class="n">e_hat_other</span> <span class="o">=</span> <span class="n">I_mat</span><span class="p">[</span><span class="n">other_dot</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">add_e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_diff_charges</span><span class="p">):</span>
                        <span class="n">charge_state</span> <span class="o">=</span> <span class="n">N_current</span> <span class="o">+</span> <span class="p">(</span><span class="n">add_e</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">e_hat</span> <span class="o">-</span> <span class="n">e_hat_other</span>
                        <span class="n">charge_state</span><span class="p">[</span><span class="n">charge_state</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="n">energies</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span>
                                <span class="n">N</span><span class="o">=</span><span class="n">charge_state</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
        <span class="n">current_energy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N_current</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">V_v</span><span class="p">)</span>
        <span class="n">dU</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">energies</span><span class="p">)</span> <span class="o">-</span> <span class="n">current_energy</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dU</span><span class="p">[</span><span class="n">dU</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_make_it_real</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">diagram</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">kernel_widths</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">3.0</span><span class="p">,</span> <span class="mf">3.0</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Uses a Gaussian filter to broaden a stickfigure diagram.</span>

<span class="sd">        Args:</span>
<span class="sd">            diagram: The previously computed stickfigure diagram</span>
<span class="sd">            kernel_width (list, float): Width of the Gaussian kernel. Can be a</span>
<span class="sd">                single number or list of the same length as the diagram&#39;s</span>
<span class="sd">                dimensions.</span>

<span class="sd">        Return:</span>
<span class="sd">            np.ndarray: Gaussian blurred diagram.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">org_shape</span> <span class="o">=</span> <span class="n">diagram</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">diagram</span> <span class="o">=</span> <span class="n">gaussian_filter</span><span class="p">(</span>
            <span class="n">diagram</span><span class="p">,</span> <span class="n">sigma</span><span class="o">=</span><span class="n">kernel_widths</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;constant&quot;</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="mi">1</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">resize</span><span class="p">(</span><span class="n">diagram</span><span class="p">,</span> <span class="n">org_shape</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_noise</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">diagram</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">target_snr_db</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">10.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Adds normally distributed random noise to a diagram to match the</span>
<span class="sd">        desired signal-to-noise ratio.</span>

<span class="sd">        Args:</span>
<span class="sd">            diagram: Noise free diagram</span>
<span class="sd">            target_snr_db: Target signal to noise ratio in dB</span>

<span class="sd">        Return:</span>
<span class="sd">            np.ndarray: Diagram with normally distributed random noise added.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">d_shape</span> <span class="o">=</span> <span class="n">diagram</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">sig_mean_power</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diagram</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">sig_avg_db</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">sig_mean_power</span><span class="p">)</span>

        <span class="n">noise_avg_db</span> <span class="o">=</span> <span class="n">sig_avg_db</span> <span class="o">-</span> <span class="n">target_snr_db</span>
        <span class="n">noise_avg_power</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="n">noise_avg_db</span> <span class="o">/</span> <span class="mi">10</span><span class="p">)</span>

        <span class="n">mean_noise</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">mean_noise</span><span class="p">,</span> <span class="n">noise_avg_power</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">d_shape</span><span class="p">))</span>
        <span class="n">noise</span> <span class="o">=</span> <span class="n">noise</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">d_shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">diagram</span> <span class="o">+</span> <span class="n">noise</span>

    <span class="k">def</span> <span class="nf">_save_to_db</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parameters</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Parameter</span><span class="p">],</span>
        <span class="n">setpoints</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span>
        <span class="n">data</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">],</span>
        <span class="n">nt_label</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">quality</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Save data to a database using QCoDeS.</span>

<span class="sd">        Args:</span>
<span class="sd">            parameters: List of QCoDeS parameters to register for</span>
<span class="sd">                measurement.</span>
<span class="sd">            setpoints: List of setpoints, i.e. voltage values.</span>
<span class="sd">            data: The measurement to save.</span>
<span class="sd">            nt_label: List of machine learning/nanotune labels to save.</span>
<span class="sd">            quality: The measurement&#39;s quality, to be saved as metadata.</span>

<span class="sd">        Returns:</span>
<span class="sd">            int: QCoDeS data run id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: Save the data as arrays and remove for loops. To be updated to</span>
        <span class="c1"># new QCoDeS data formats</span>

        <span class="n">dummy_lockin</span> <span class="o">=</span> <span class="n">DummyInstrument</span><span class="p">(</span><span class="s2">&quot;dummy_lockin&quot;</span><span class="p">,</span> <span class="n">gates</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Only 1D and 2D sweeps supported right now.&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="n">meas</span> <span class="o">=</span> <span class="n">Measurement</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">meas</span><span class="o">.</span><span class="n">register_parameter</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">meas</span><span class="o">.</span><span class="n">register_parameter</span><span class="p">(</span><span class="n">dummy_lockin</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">setpoints</span><span class="o">=</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],))</span>

            <span class="k">with</span> <span class="n">meas</span><span class="o">.</span><span class="n">run</span><span class="p">()</span> <span class="k">as</span> <span class="n">datasaver</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x_indx</span><span class="p">,</span> <span class="n">x_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">setpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">x_val</span><span class="p">)</span>
                    <span class="n">datasaver</span><span class="o">.</span><span class="n">add_result</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_val</span><span class="p">),</span> <span class="p">(</span><span class="n">dummy_lockin</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">x_indx</span><span class="p">])</span>
                    <span class="p">)</span>

                <span class="n">dataid</span> <span class="o">=</span> <span class="n">datasaver</span><span class="o">.</span><span class="n">run_id</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parameters</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">meas</span><span class="o">.</span><span class="n">register_parameter</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">meas</span><span class="o">.</span><span class="n">register_parameter</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">meas</span><span class="o">.</span><span class="n">register_parameter</span><span class="p">(</span>
                <span class="n">dummy_lockin</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">setpoints</span><span class="o">=</span><span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>

            <span class="k">with</span> <span class="n">meas</span><span class="o">.</span><span class="n">run</span><span class="p">()</span> <span class="k">as</span> <span class="n">datasaver</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">x_indx</span><span class="p">,</span> <span class="n">x_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">setpoints</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">x_val</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">y_indx</span><span class="p">,</span> <span class="n">y_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">setpoints</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">](</span><span class="n">y_val</span><span class="p">)</span>
                        <span class="n">datasaver</span><span class="o">.</span><span class="n">add_result</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x_val</span><span class="p">),</span>
                            <span class="p">(</span><span class="n">parameters</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">y_val</span><span class="p">),</span>
                            <span class="p">(</span><span class="n">dummy_lockin</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">x_indx</span><span class="p">,</span> <span class="n">y_indx</span><span class="p">]),</span>
                        <span class="p">)</span>

                <span class="n">dataid</span> <span class="o">=</span> <span class="n">datasaver</span><span class="o">.</span><span class="n">run_id</span>

        <span class="n">ds</span> <span class="o">=</span> <span class="n">load_by_id</span><span class="p">(</span><span class="n">dataid</span><span class="p">)</span>

        <span class="n">meta_add_on</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span>
            <span class="n">nt</span><span class="o">.</span><span class="n">config</span><span class="p">[</span><span class="s2">&quot;core&quot;</span><span class="p">][</span><span class="s2">&quot;meta_fields&quot;</span><span class="p">],</span> <span class="kc">None</span>
        <span class="p">)</span>
        <span class="n">meta_add_on</span><span class="p">[</span><span class="s2">&quot;device_name&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="n">nm</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">([</span><span class="s2">&quot;transport&quot;</span><span class="p">,</span> <span class="s2">&quot;rf&quot;</span><span class="p">],</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">meta_add_on</span><span class="p">[</span><span class="s2">&quot;normalization_constants&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">nm</span>

        <span class="n">ds</span><span class="o">.</span><span class="n">add_metadata</span><span class="p">(</span><span class="n">nt</span><span class="o">.</span><span class="n">meta_tag</span><span class="p">,</span> <span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">meta_add_on</span><span class="p">))</span>

        <span class="n">current_label</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">LABELS</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">nt_label</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">label</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">LABELS</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;CapacitanceModel: Invalid label: </span><span class="si">{</span><span class="n">label</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
                <span class="n">current_label</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">current_label</span><span class="p">[</span><span class="s2">&quot;good&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quality</span>

        <span class="k">for</span> <span class="n">label</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">current_label</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">ds</span><span class="o">.</span><span class="n">add_metadata</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

        <span class="n">dummy_lockin</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">dataid</span>

<div class="viewcode-block" id="CapacitanceModel.determine_sweep_voltages"><a class="viewcode-back" href="../../../api/model/capacitancemodel.html#nanotune.model.capacitancemodel.CapacitanceModel.determine_sweep_voltages">[docs]</a>    <span class="k">def</span> <span class="nf">determine_sweep_voltages</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">voltage_node_idx</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
        <span class="n">V_v</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">N_limits</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">N_lmt_type</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;Determines voltages to sweep to measure specific charge transitions.</span>

<span class="sd">        Args:</span>
<span class="sd">            voltage_node_idx: Indices of voltages nodes to sweep.</span>
<span class="sd">            V_v: Voltage configuration of all gates.</span>
<span class="sd">            N_limits: Charge configuration ranges to measure. E.g. for a double</span>
<span class="sd">                dot to sweep over empty dots to both having 3 electrons: [(0, 3), (0, 3)]</span>

<span class="sd">        Returns:</span>
<span class="sd">            list: Nested list of voltages limits to sweep. Example double dot:</span>
<span class="sd">                [[gate1_min_voltage, gate1_max_voltage], [gate2_min_voltage, gate2_max_voltage]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">V_v</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">V_v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">V_v</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">N_limits</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">N_limits</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">())</span>

        <span class="n">N_init</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">did</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N_limits</span><span class="p">)):</span>
            <span class="n">N_init</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N_limits</span><span class="p">[</span><span class="n">did</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">eng_sub_fct</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">swept_voltages</span><span class="p">):</span>
            <span class="n">curr_V</span> <span class="o">=</span> <span class="n">V_v</span>
            <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">v_to_sweep</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">voltage_node_idx</span><span class="p">):</span>
                <span class="n">curr_V</span><span class="p">[</span><span class="n">v_to_sweep</span><span class="p">]</span> <span class="o">=</span> <span class="n">swept_voltages</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_energy</span><span class="p">(</span><span class="n">N</span><span class="o">=</span><span class="n">N</span><span class="p">,</span> <span class="n">V_v</span><span class="o">=</span><span class="n">curr_V</span><span class="p">)</span>

        <span class="n">eng_fct</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">eng_sub_fct</span><span class="p">,</span> <span class="n">N_init</span><span class="p">)</span>
        <span class="n">x0</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">v_to_sweep</span> <span class="ow">in</span> <span class="n">voltage_node_idx</span><span class="p">:</span>
            <span class="n">x0</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">V_v</span><span class="p">[</span><span class="n">v_to_sweep</span><span class="p">])</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
            <span class="n">eng_fct</span><span class="p">,</span>
            <span class="n">x0</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">V_init_config</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span>

        <span class="n">N_stop</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">did</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">N_limits</span><span class="p">)):</span>
            <span class="n">N_stop</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">N_limits</span><span class="p">[</span><span class="n">did</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">eng_fct</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">eng_sub_fct</span><span class="p">,</span> <span class="n">N_stop</span><span class="p">)</span>

        <span class="n">x0</span> <span class="o">=</span> <span class="n">V_init_config</span>

        <span class="n">res</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">optimize</span><span class="o">.</span><span class="n">minimize</span><span class="p">(</span>
            <span class="n">eng_fct</span><span class="p">,</span>
            <span class="n">x0</span><span class="p">,</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Nelder-Mead&quot;</span><span class="p">,</span>
            <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">V_stop_config</span> <span class="o">=</span> <span class="n">res</span><span class="o">.</span><span class="n">x</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">V_init_config</span><span class="p">,</span> <span class="n">V_stop_config</span><span class="p">))</span>  <span class="c1"># type: ignore</span></div>

    <span class="k">def</span> <span class="nf">_get_N</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter getter for charge configuration N. &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">inn</span><span class="p">,</span> <span class="n">c_n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_N</span><span class="p">[</span><span class="n">inn</span><span class="p">]</span> <span class="o">=</span> <span class="n">c_n</span><span class="o">.</span><span class="n">n</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_N</span>

    <span class="k">def</span> <span class="nf">_set_N</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter setter for charge configuration N. &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_N</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span><span class="o">.</span><span class="n">n</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_get_V_v</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter getter for voltage configuration V_v. &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">inn</span><span class="p">,</span> <span class="n">v_n</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">voltage_nodes</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_V_v</span><span class="p">[</span><span class="n">inn</span><span class="p">]</span> <span class="o">=</span> <span class="n">v_n</span><span class="o">.</span><span class="n">v</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_V_v</span>

    <span class="k">def</span> <span class="nf">_set_V_v</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]):</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter setter for voltage configuration V_v. &quot;&quot;&quot;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_V_v</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">for</span> <span class="n">iv</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">voltage_nodes</span><span class="p">[</span><span class="n">iv</span><span class="p">]</span><span class="o">.</span><span class="n">v</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_C_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter getter for dot capacitance matrix C_cc. Diagonals</span>
<span class="sd">        of C_cc is the sum of all capacitances connected to the respective</span>
<span class="sd">        charge node, calculated in _get_C_cc_diagonals.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">current_C_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span><span class="p">)</span>
        <span class="n">diagonals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_C_cc_diagonals</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">dot_ind</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">)):</span>
            <span class="n">current_C_cc</span><span class="p">[</span><span class="n">dot_ind</span><span class="p">,</span> <span class="n">dot_ind</span><span class="p">]</span> <span class="o">=</span> <span class="n">diagonals</span><span class="p">[</span><span class="n">dot_ind</span><span class="p">,</span> <span class="n">dot_ind</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span> <span class="o">=</span> <span class="n">current_C_cc</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span>

    <span class="k">def</span> <span class="nf">_set_C_cc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">off_diagonals</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter setter for dot capacitance matrix C_cc. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">)])</span>
        <span class="k">for</span> <span class="n">dinx</span><span class="p">,</span> <span class="n">diagonal</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">off_diagonals</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">diagonal</span><span class="p">)</span> <span class="o">!=</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">charge_nodes</span><span class="p">)</span> <span class="o">-</span> <span class="n">dinx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                    <span class="s2">&quot;CapacitanceModel: Unable to set C_cc. &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;Please specify off diagonals in a list of &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;lists: [[1st off diagonal], &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;[2nd off diagonal]]&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">dinx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diagonal</span><span class="p">,</span> <span class="n">k</span><span class="o">=-</span><span class="n">dinx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_C_cc_diagonals</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_C_cc_diagonals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Getter for diagonal values of dot capacitance matrix C_cc.</span>
<span class="sd">        We assume that every dot is coupled to every other, meaning that</span>
<span class="sd">        that if three or more dots are aligned the first will have a capacitive</span>
<span class="sd">        coupling to the last. In the same manner, all dots are coupled to the</span>
<span class="sd">        leads. Change if necessary.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">C_cv_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_C_cv</span><span class="p">)),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># from other dots:</span>
        <span class="n">off_diag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_C_cc</span><span class="p">))</span>
        <span class="n">off_diag_sums</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">off_diag</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">diag</span> <span class="o">=</span> <span class="n">C_cv_sums</span> <span class="o">+</span> <span class="n">off_diag_sums</span>
        <span class="n">diag</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c_r</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_c_r</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">diag</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_C_cv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter getter for dot capacitance matrix C_cv. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_C_cv</span>

    <span class="k">def</span> <span class="nf">_set_C_cv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]):</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter setter for dot capacitance matrix C_cv. Updates dot</span>
<span class="sd">        capacitance matrix C_cc as its diagonals depend on C_cv</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_C_cv</span> <span class="o">=</span> <span class="n">value</span>
        <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_C_cc</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_get_c_r</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter getter for lead capacitance R(right). &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_r</span>

    <span class="k">def</span> <span class="nf">_set_c_r</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter setter for lead capacitance R(right). Updates dot</span>
<span class="sd">        capacitance matrix C_cc as its diagonals depend on c_r</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_r</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_C_cc</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Setting CapacitanceModel.c_r: Unable to update C_cc&quot;</span>
            <span class="p">)</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_get_c_l</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter getter for lead capacitance L(eft). &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_c_l</span>

    <span class="k">def</span> <span class="nf">_set_c_l</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">float</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; QCoDeS parameter setter for lead capacitance L(eft). Updates dot</span>
<span class="sd">        capacitance matrix C_cc as its diagonals depend on c_l</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_c_l</span> <span class="o">=</span> <span class="n">value</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_C_cc</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                <span class="s2">&quot;Setting CapacitanceModel.c_l: Unable to update C_cc&quot;</span>
            <span class="p">)</span>
            <span class="k">pass</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2021, Jana Darulova.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>